
function  metsimspk ( MC )
% 
% metsimspk ( MC )
% 
% Matlab Electrophysiology Toolbox controller function. PsychPortAudio is
% used to turn the sound card into a simple digital-to-analogue signal
% generator that produces a simulated spike train with a dynamic firing
% rate. An audio cable plugged into the computer's audio jack can then have
% the free end suspended in saline solution, alongside a test electrode.
% The simulated firing rate can change in response to trial events. Thus,
% the entire experimental setup can be tested.
% 
% Simulated spike trains can have either a baseline or test firing rate,
% during a trial. The baseline rate never changes, but the test firing rate
% can be made to vary with a scheduled stimulus task variable (see session
% schedule.txt files for names). The range of task variable values will be
% normalised between 0 and 1, then multiplied into a maximum possible
% firing rate to arrive at a test rate. Hence, the test rate will vary from
% trial to trial in correlation with the named task variable. The
% simulation will switch from a baseline firing rate to the test firing
% rate whenever a named task stimulus is being presented (see task logic
% files for names).
% 
% Spike trains are freshly generated for each trial by sampling spike times
% from a Poisson distribution, and then excluding any spikes that fall
% within a 2ms refractory period. The spike train is then convolved with a
% kernel to produce a continuous signal. The kernel is a 1 ms pulse from a
% 1000Hz sinusoid ; in other words, an action-potential-like waveform is
% used. The continuous signal is then generated by playing it out through
% the audio device.
%
% metsimspk.csv is a MET csv parameter file that provides the name of the
% scheduled task variable, the name of a task stimulus, and various spiking
% parameters. The csv parameters are:
% 
%   taskvar - Name of the task variable , a string
%   tvnorm - A flag saying how to normalise taskvar's values. The flag
%     takes a single character. If 'c' then the median value of tvnorm will
%     be normalised to 1, with the value furtherst from that being
%     normalised to 0. Otherwise, a flag character of 'x' will normalise
%     the maXimum task variable value to 1, and the minimum to 0.
%     Alternatively, 'n' the miNimum value is normalised to 1 and the
%     maximum to 0.
%   taskstim - Name of the task stimulus , a string
%   faudio - Frequency of audio sampling rate , in Hz
%   kernwidth - Width of the kernel , in seconds
%   kernfreq - Frequency of the kernel sinusoid , in Hz
%   baseline - Baseline firing rate , in Hz
%   maxtest - Maximum possible firing rate , in Hz
%   refract - The refractory period duration , in seconds
%   basedur - Duration of baseline signal to create per trial , in seconds
%   testdur - Duration of test signal to create per trial , in seconds
% 
% Example metsimspk.csv:
% 
%     param,value
%     taskvar,DistractorDisparity
%     tvnorm,c
%     taskstim,distractor
%     faudio,44100
%     kernwidth,0.001
%     kernfreq,1000
%     baseline,10
%     maxtest,150
%     refract,0.002
%     basedur,10
%     testdur,5
% 
% Written by Jackson Smith - July 2017 - DPAG , University of Oxford
% 
	
  
  %%% Constants %%%
  
  % Name of parameter csv file
  CSV = strrep (  which ( 'metsimspk' )  ,  '.m'  ,  '.csv'  ) ;
  
  % List of required parameter names
  PARNAM = { 'taskvar' , 'tvnorm' , 'taskstim' , 'faudio' , ...
    'kernwidth' , 'kernfreq' , 'baseline' , 'maxtest' , 'refract' , ...
    'basedur' , 'testdur' } ;
  
  % First numeric parameter's index , in PARNAM
  INUM = 4 ;
  
  % tvnorm allowable character set
  TVNORM = 'cxn' ;
  
  
  %%% Parameters %%%
  
  % Read in parameters
  p = metreadcsv (  CSV  ,  PARNAM  ,  PARNAM ( INUM : end )  ) ;
  
  % Check that tvnorm flag is a single character of the correct kind
  if  numel (  p.tvnorm  )  ~=  1  ||  ~ any (  p.tvnorm  ==  TVNORM  )
    
    error (  'MET:metsimspk:tvnorm'  ,  [ 'metsimspk: tvnorm must be ' ,...
      'one of the following characters: %s' ]  ,  TVNORM  )
    
  % Check that taskstim is not 'none'
  elseif  strcmp (  p.taskstim  ,  'none'  )
    
    error (  'MET:metsimspk:taskstim'  ,  ...
      'metsimspk: taskstim must not be ''none'''  )
    
  end % tvnorm check
  
  % Check that all numeric values are non-zero
  for  i = INUM : numel ( PARNAM )
    
    % Parameter name
    n = PARNAM { i } ;
    
    % Check value
    if  p.( n )  <=  0
      
      error (  'MET:metsimspk:tvnorm'  ,  [ 'metsimspk: parameter %s ' ,...
        'is less than or equal to zero' ]  ,  n  )
      
    end
    
  end % check non-zero numbers
  
  
  %%% Build kernel %%%
  
  % Time of each sample , in seconds
  k = single(  ( 0 : ceil( p.kernwidth * p.faudio ) - 1 )  /  p.faudio  ) ;
  
  % Shape of kernel
  k = sin (  2  *  pi  *  p.kernfreq  *  k  ) ;
  
  
  %%% Prepare audio devices %%%
  
  % Initialise driver
  InitializePsychSound ;
  
  % Open master sound device 9 = 1 + 8 , playback plus master device
  mpa = PsychPortAudio ( 'open' , [] , 9 , [] , p.faudio ) ;

  % Now open slave devices, one per firing rate. Order of elements is
  % [ baseline spike rate , test spike rate ]. This convention holds with
  % runc variables.
  spa = [  PsychPortAudio( 'OpenSlave' , mpa )  ,  ...
           PsychPortAudio( 'OpenSlave' , mpa )  ] ;
         
	% Start master playback
  PsychPortAudio (  'Start'  ,  mpa  ,  0  ,  0  ,  1  ) ;
  
  % Clear unneeded variable
  clear  mpa
  
  
  %%% Run controller %%%
  
  % Empty means no error detected
  E = '' ;
  
  % Catch any errors raised during operation
  try
    
    runc ( MC , p , k , spa )
    
  catch  E
  end
  
  % Clear PsychToolbox resources
  try
    PsychPortAudio ( 'Close' ) ;
    sca
  catch
  end
  
  % Report error
  if  ~ isempty ( E )  ,  rethrow ( E )  ,  end
  
  
end % metsimspk


%%% Subroutines %%%


% Runs the controller. Received MET compile-time constants, controller .csv
% parameters, kernel vector, and slave Port Audio device handles.
function  runc ( MC , p , k , spa )
  
  
  %%% Constants %%%
  
  % MET controller constants
  MCC = metctrlconst ( MC ) ;
  
  % MET signal identifier name-to-value map
  MSID = MCC.MSID ;
  
  % Blocking on MET signalling i.e. wait for operation
  WAIT_FOR_SIG = 1 ;
  
  
  %%% Variables %%%
  
  % Spike rates [ baseline , test ]. Baseline computed once. Test computed
  % each trial.
  r = [  p.baseline / p.faudio  ,  0  ] ;
  
  % Number of samples 
  n = ceil (  [  p.basedur  ,  p.testdur  ]  *  p.faudio  ) ;
  
  
  %%% Complete MET initialisation %%%
  
  % Send mready signal , non-blocking
  met ( 'send' , MSID.mready , MC.MREADY.REPLY , [] ) ;
  
  % Report
  met (  'print'  ,  ...
    sprintf ( 'MET controller %d initialised: metsimspk' , MC.CD )  ,  ...
    'L'  )
  
  % Flush any outstanding messages to terminal
  met ( 'flush' )
  
  % Wait for mwait signal that finalises initialisation phase
  i = 0 ;
  sig = [] ;
  while  ~ i  ||  all ( sig  ~=  MSID.mwait )
    
    % Block on the next MET signal(s)
    [ i , ~ , sig ] = met ( 'recv' , 1 ) ;

    % Return if any mquit signal received
    if  any ( sig  ==  MSID.mquit )  ,  return  ,  end
  
  end % initialising mwait
  
  
  %%% Trial loop %%%
  
  % Blank session descriptor is required for first iteration of the loop
  sd = MCC.DAT.SD ;
  
  % Wait for next trial
  while  metwaitfortrial ( MC , 'metsimspk' )
    
    
    %-- Get trial parameters --%
    
    % Read current session directory name and trial identifier
    [ sdir , tid ] = metsdpath ;
    
    % Session directory has changed
    if  ~ strcmp (  sd.session_dir  ,  sdir  )
      
      % Load new session descriptor
      sd = metdload ( MC , MCC , sdir , tid , 'sd' , 'metsimspk' ) ;
      
      % Look for named task variable. If found then return normalising
      % coefficients and the task logic indices for states with the named
      % task stimulus. Otherwise, return empty arrays.
      [ c , s ] = sessprep ( p , sd ) ;

    end % new sess dir
    
    % Load new trial descriptor
    td = metdload ( MC , MCC , sdir , tid , 'td' , 'metptb' ) ;
    
    % Look for task variable value and return a weight to apply to the
    % maximum test firing rate
    w = getweight ( p , sd , td , c ) ;
    
    % Calculate test firing rate per sample
    r( 2 ) = p.maxtest  *  w  /  p.faudio ;
    
    
    %-- Simulate fresh spike trains --%
    
    % Loop slave audio devices: baseline , test
    for  i = 1 : numel ( spa )
      
      % Making test spike train but task stimulus unavailable , skip
      if  i == 2  &&  ~ w  ,  continue  ,  end
      
      % Generate binary spike train
      x = rand ( 1 , n( i ) )  <  r( i ) ;
      
      % Remove spikes in refractory period. First, get spike times
      t = find ( x )  *  p.faudio ;
      
      % Now find spikes that are in a refractory period
      j = find ( diff( t )  <=  p.refract )  +  1 ;
      
      % Remove refractory spikes
      x( j ) = 0 ;
      
      % Convolve binary spike train to a waveform
      x = conv (  single ( x )  ,  k  ) ;
      
      % Normalise by absolute maximum , scales range from -1 to +1
      x = x  /  max ( abs(  x  ) ) ;
      
      % Add to sound buffer
      PsychPortAudio (  'FillBuffer'  ,  spa( i )  ,  [ x ; x ]  ) ;
      
    end % slave audio devices
    
    
    %-- Final initialisation --%
    
    % Test rate flag , non-zero when test firing rate is in use. Zero for
    % baseline. Initialise based on whether named task stimulus is present
    % in the start state.
    tstflg = any ( sd.logic.( td.logic ).istate.start  ==  s ) ;
    
    
    %-- Synchronise start of trial with MET --%
    
    % Send mready reply to MET server controller , blocking write
    met ( 'send' , MSID.mready , MC.MREADY.REPLY , [] , WAIT_FOR_SIG ) ;
    
    % Wait for start of trial MET signal mstart
    while  ~ any ( i )
      
      % Block on the broadcast pipe
      [ ~ , ~ , sig ] = met (  'recv'  ,  WAIT_FOR_SIG  ) ;
      
      % Immediately terminate the function if a quit signal received ,
      % after closing stimulus descriptors
      if  any ( sig  ==  MSID.mquit )
        
        return
      
      % Break loop if start signal received
      elseif  any ( sig  ==  MSID.mstart )
        
        break
        
      end
      
    end % mstart
    
    % Start spike train playback
    PsychPortAudio (  'Start'  ,  spa ( tstflg + 1 )  ,  0  ) ;
    
    
    %-- Trial event loop --%
    
    while  true
      
      
      %-- Signal handling --%
      
      % Wait for MET signals , block on the broadcast pipe
      [ i , ~ , sig , crg ] = met (  'recv'  ,  WAIT_FOR_SIG  ) ;
      
      % Signals received
      if  i
        
        % Quit signal
        if  any ( sig  ==  MSID.mquit )
          
          % Terminate function now
          return
        
        % mwait abort or mstop signal received
        elseif  ( any( sig  ==  MSID.mwait )  &&  ...
                    any( crg  ==  MC.MWAIT.ABORT ) )  ||  ...
                      any( sig  ==  MSID.mstop )
          
          % End trial now
          break
          
        % Test firing rate weight is zero , hence task stimulus unavailable
        % and test firing rate will not occur
        elseif  ~ w
          
          % Wait for new MET signals
          continue
          
        end % mwait
        
        % Look for change of state signal
        i = find ( sig  ==  MSID.mstate ) ;
        
        % No change of state , wait for new MET signals
        if  isempty (  i  )  ,  continue  ,  end
        
      end % signal handling
      
      
      %-- Handle change of state --%
      
      % Get cargo of last mstate signal , this is a state index
      crg = crg ( i(  end  ) ) ;
      
      % If state index is in the list while the test flag is up then no
      % changes. Otherwise if the index is not in the list while the flag
      % is down, then again no change.
      if  (  tstflg  &&  any ( crg  ==  s ) )  ||  ...
          ( ~tstflg  &&  all ( crg  ~=  s ) )
        
        % Wait for new signals
        continue
        
      end % no change required
      
      % The firing rate must changed. Stop the current firing rate.
      PsychPortAudio (  'Stop'  ,  spa ( tstflg + 1 )  ) ;
      
      % Switch flag state to signal the other firing rate
      tstflg = ~ tstflg ;
      
      % And start playing the other firing rate
      PsychPortAudio ( 'Start' , ...
        spa( tstflg + 1 ) , 0 , [] , [] , [] , 1 ) ;
      
    end % trial event loop
    
    
    %-- End of trial --%
    
    % Stop audio output
    PsychPortAudio (  'Stop'  ,  spa ( tstflg + 1 )  ) ;
    
    
  end % trial loop
  
  
end % runc


% Check requested task variable. Find normalisation terms according to
% normalisation method. Returns vector of coefficients or [] if task
% variable is missing or not scheduled. The coefficients are, in order, a
% centring term and a scaling term. Hence, for task variable value v, the
% normalised value will be ( v  -  c( 1 ) ) * c( 2 ). In addition, return
% task logic indices of states that present the requested task stimulus.
function  [ c , s ] = sessprep ( p , sd )
  
  % Default return
  c = [] ;  s = [] ;
  
  
  %%% Check task variable %%%
  
  % Get task variable name list
  n = fieldnames ( sd.var ) ;
  
  % Task variable required by controller
  t = p.taskvar ;
  
  % Look for error , if non-empty then an error was found
  e = '' ;
  
  % Task variable not in this session
  if  ~ any ( strcmp(  n  ,  p.taskvar  ) )
    
    e = sprintf ( 'metsimspk: task var %s not available' , p.taskvar ) ;
    
  % Check if task variable is scheduled
  elseif  ~ strcmp (  sd.var.( t ).dist  ,  'sched'  )
    
    e = sprintf ( 'metsimspk: task var %s not scheduled' , p.taskvar ) ;
    
  % Check if task variable is type stim
  elseif  ~ strcmp (  sd.var.( t ).type  ,  'stim'  )
    
    e = sprintf ( 'metsimspk: task var %s not type stim' , p.taskvar ) ;
    
  end % named task var
  
  % Error found , report and return empty coefficients
  if  ~ isempty ( e )
    met (  'print'  ,  e  ,  'E'  )
    return
  end
  
  
  %%% Get normalisation coefficients %%%
  
  % Now we can re-initialise c. Give it a centring term of 0 and a scaling
  % term of 1
  c = [ 0 , 1 ] ;
  
  % Get set of task variable values
  v = sd.var.( t ).value ;
  
  % There is a single value , return re-initialised coefficients
  if  isscalar ( v )  ,  return  ,  end
  
  % Find slope and y-intercept according to requested method flagged in
  % tvnorm
  switch  p.tvnorm
    
    % Normalise the median to 1
    case  'c'
      
      % Find median for the centring term
      c( 1 ) = median ( v ) ;
      
      % Normalise each value so that median is zero and all values are
      % positive
      v = abs ( v  -  c( 1 ) ) ;
      
      % Find scaling term
      c( 2 ) = 1  /  max ( v ) ;
      
      % Scaling then inversion i.e. 1  -  v normalised the median to 1
      
    % Normalise so that minimum is zero and maximum is 1
    case  'x'
      
      % Subtract minimum
      c( 1 ) = min ( v ) ;
      
      % Scale by reciprocal of the difference with maximum
      c( 2 ) = 1  /  ( max( v )  -  c( 1 ) ) ;
      
      
    % Normalise so that maximum is zero and minimum is 1
    case  'n'
      
      % Subtract maximum
      c( 1 ) = max ( v ) ;
      
      % Scale by reciprocal of the difference with minimum
      c( 2 ) = 1  /  ( min( v )  -  c( 1 ) ) ;
      
      
  end % get coefficients
  
  
  %%% Get list of task logic state indices %%%
  
  % First, get the name of the task linked to the task variable
  n = sd.var.( t ).task ;
  
  % Next get the name of the task logic
  n = sd.task.( n ).logic ;
  
  % Finally , get the task logic
  l = sd.logic.( n ) ;
  
  % Check that the named task stimulus is available
  if  ~ any ( strcmp(  l.nstim  ,  p.taskstim  ) )
    
    % Not available , inform user
    met (  'print'  ,  sprintf ( [ 'metsimspk: task stimulus %s ' , ...
      'not found in task logic %s' ] , p.taskstim , n )  ,  'E'  )
    
    % Return empties
    c = [] ;
    return
    
  end % check task stim
  
  % Stimulus index
  i = l.istim.( p.taskstim ) ;
  
  % List of state names
  n = l.nstate ;
  
  % Get index of names for states that present that stimulus
  j = cellfun (  @( c )  any ( l.stim.( c ) ==  i ) ,  n  ) ;
  
  % Turn state names to indices
  s = cellfun (  @( c )  l.istate.( c )  ,  n( j )  ) ;
  
  
end % findtvar


% Lookup the task variable value on this trial and return corresponding
% weight on maximum test firing rate. Returns zero when task variable is
% unavailable.
function  w = getweight ( p , sd , td , c )
  
  % Default weight of zero
  w = 0 ;
  
  % Task variable not in session , return zero
  if  isempty ( c )  ,  return  ,  end
  
  % Task variable name
  t = p.taskvar ;
  
  % Block's list does not have task variable , return zero
  if  ~ any ( strcmp(  sd.block.( td.block_name ).var  ,  t  ) )
    return
  end
  
  % Lookup variable value from stimulus link , get the name of the link and
  % variable parameter
  s = sd.var.( t ).name ;
  v = sd.var.( t ).vpar ;
  
  % Find stimlink index
  i = strcmp (  { td.stimlink.name }  ,  s  ) ;
  
  % Get variable parameter value i.e. task variable value
  w = td.stimlink( i ).vpar.( v ) ;
  
  % Transform into weight
  w = ( w  -  c( 1 ) )  *  c( 2 ) ;
  
  % If normalising median then we need an extra step to bring it from zero
  % to 1. Recall, we've subtracted median and then scaled values from -1 to
  % 1. Hence absolute scales range from 0 (median) to 1. Subtracting that
  % from 1 then makes the median 1, and all other values move towards 0,
  % proportionally.
  if  p.tvnorm  ==  'c'  ,  w = 1  -  abs ( w ) ;  end
  
end % getweight

